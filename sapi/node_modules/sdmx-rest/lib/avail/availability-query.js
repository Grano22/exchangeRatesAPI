// Generated by CoffeeScript 2.5.1
(function() {
  var AvailabilityMode, AvailabilityQuery, AvailabilityReferences, FlowRefType, MultipleProviderRefType, NestedNCNameIDType, SeriesKeyType, ValidQuery, createErrorMessage, defaults, isValidDate, isValidEnum, isValidPattern, isValidPeriod, isValidQuery, query, toKeyString, toProviderString,
    hasProp = {}.hasOwnProperty;

  ({AvailabilityMode} = require('./availability-mode'));

  ({AvailabilityReferences} = require('./availability-references'));

  ({FlowRefType, SeriesKeyType, MultipleProviderRefType, NestedNCNameIDType} = require('../utils/sdmx-patterns'));

  ({isValidEnum, isValidPattern, isValidPeriod, isValidDate, createErrorMessage} = require('../utils/validators'));

  defaults = {
    key: 'all',
    provider: 'all',
    component: 'all',
    mode: AvailabilityMode.EXACT,
    references: AvailabilityReferences.NONE
  };

  ValidQuery = {
    flow: function(i, e) {
      return isValidPattern(i, FlowRefType, 'flows', e);
    },
    key: function(i, e) {
      return isValidPattern(i, SeriesKeyType, 'series key', e);
    },
    provider: function(i, e) {
      return isValidPattern(i, MultipleProviderRefType, 'provider', e);
    },
    component: function(i, e) {
      return isValidPattern(i, NestedNCNameIDType, 'component', e);
    },
    start: function(i, e) {
      return !i || isValidPeriod(i, 'start period', e);
    },
    end: function(i, e) {
      return !i || isValidPeriod(i, 'end period', e);
    },
    updatedAfter: function(i, e) {
      return !i || isValidDate(i, 'updatedAfter', e);
    },
    mode: function(i, e) {
      return isValidEnum(i, AvailabilityMode, 'mode', e);
    },
    references: function(i, e) {
      return isValidEnum(i, AvailabilityReferences, 'references', e);
    }
  };

  isValidQuery = function(q) {
    var errors, isValid, k, v;
    errors = [];
    isValid = false;
    for (k in q) {
      if (!hasProp.call(q, k)) continue;
      v = q[k];
      isValid = ValidQuery[k](v, errors);
      if (!isValid) {
        break;
      }
    }
    return {
      isValid: isValid,
      errors: errors
    };
  };

  toKeyString = function(dims) {
    var d;
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = dims.length; j < len; j++) {
        d = dims[j];
        results.push(Array.isArray(d) ? d.join('+') : d != null ? d : '');
      }
      return results;
    })()).join('.');
  };

  toProviderString = function(p) {
    return p.join('+');
  };

  // A query for data availability, as defined by the SDMX RESTful API.
  query = AvailabilityQuery = class AvailabilityQuery {
    static from(opts) {
      var input, key, pro, ref, ref1, ref2, ref3, ref4;
      key = (ref = opts != null ? opts.key : void 0) != null ? ref : defaults.key;
      if (Array.isArray(key)) {
        key = toKeyString(key);
      }
      pro = (ref1 = opts != null ? opts.provider : void 0) != null ? ref1 : defaults.provider;
      if (Array.isArray(pro)) {
        pro = toProviderString(pro);
      }
      query = {
        flow: opts != null ? opts.flow : void 0,
        key: key,
        provider: pro,
        component: (ref2 = opts != null ? opts.component : void 0) != null ? ref2 : defaults.component,
        start: opts != null ? opts.start : void 0,
        end: opts != null ? opts.end : void 0,
        updatedAfter: opts != null ? opts.updatedAfter : void 0,
        mode: (ref3 = opts != null ? opts.mode : void 0) != null ? ref3 : defaults.mode,
        references: (ref4 = opts != null ? opts.references : void 0) != null ? ref4 : defaults.references
      };
      input = isValidQuery(query);
      if (!input.isValid) {
        throw Error(createErrorMessage(input.errors, 'availability query'));
      }
      return query;
    }

  };

  exports.AvailabilityQuery = query;

}).call(this);
