// Generated by CoffeeScript 2.5.1
(function() {
  var AgenciesRefType, MetadataDetail, MetadataQuery, MetadataReferences, MetadataType, MultipleIDType, MultipleNestedIDType, MultipleVersionsType, ValidQuery, canHaveItem, createErrorMessage, defaults, isItemScheme, isValidEnum, isValidPattern, isValidQuery, query, toQueryParam,
    hasProp = {}.hasOwnProperty;

  ({MetadataDetail} = require('./metadata-detail'));

  ({MetadataReferences} = require('./metadata-references'));

  ({MetadataType, isItemScheme} = require('./metadata-type'));

  ({AgenciesRefType, MultipleIDType, MultipleVersionsType, MultipleNestedIDType} = require('../utils/sdmx-patterns'));

  ({isValidEnum, isValidPattern, createErrorMessage} = require('../utils/validators'));

  defaults = {
    agency: 'all',
    id: 'all',
    version: 'latest',
    detail: MetadataDetail.FULL,
    references: MetadataReferences.NONE,
    item: 'all'
  };

  canHaveItem = function(query, errors) {
    var allowed;
    allowed = query.item === 'all' || isItemScheme(query.resource);
    if (!allowed) {
      errors.push(`${query.resource} is not an item scheme and therefore it is not possible to query by item`);
    }
    return allowed;
  };

  ValidQuery = {
    resource: function(q, i, e) {
      return isValidEnum(i, MetadataType, 'resources', e);
    },
    agency: function(q, i, e) {
      return isValidPattern(i, AgenciesRefType, 'agencies', e);
    },
    id: function(q, i, e) {
      return isValidPattern(i, MultipleIDType, 'resource ids', e);
    },
    version: function(q, i, e) {
      return isValidPattern(i, MultipleVersionsType, 'versions', e);
    },
    detail: function(q, i, e) {
      return isValidEnum(i, MetadataDetail, 'details', e);
    },
    references: function(q, i, e) {
      return isValidEnum(i, MetadataReferences, 'references', e);
    },
    item: function(q, i, e) {
      return isValidPattern(i, MultipleNestedIDType, 'items', e) && canHaveItem(q, e);
    }
  };

  isValidQuery = function(query) {
    var errors, isValid, k, v;
    errors = [];
    isValid = false;
    for (k in query) {
      if (!hasProp.call(query, k)) continue;
      v = query[k];
      isValid = ValidQuery[k](query, v, errors);
      if (!isValid) {
        break;
      }
    }
    return {
      isValid: isValid,
      errors: errors
    };
  };

  toQueryParam = function(p) {
    return p.join('+');
  };

  // A query for structural metadata, as defined by the SDMX RESTful API.
  query = MetadataQuery = class MetadataQuery {
    static from(opts) {
      var a, id, input, item, ref, ref1, ref2, ref3, ref4, ref5, vs;
      a = (ref = opts != null ? opts.agency : void 0) != null ? ref : defaults.agency;
      if (Array.isArray(a)) {
        a = toQueryParam(a);
      }
      id = (ref1 = opts != null ? opts.id : void 0) != null ? ref1 : defaults.id;
      if (Array.isArray(id)) {
        id = toQueryParam(id);
      }
      vs = (ref2 = opts != null ? opts.version : void 0) != null ? ref2 : defaults.version;
      if (Array.isArray(vs)) {
        vs = toQueryParam(vs);
      }
      item = (ref3 = opts != null ? opts.item : void 0) != null ? ref3 : defaults.item;
      if (Array.isArray(item)) {
        item = toQueryParam(item);
      }
      query = {
        resource: opts != null ? opts.resource : void 0,
        agency: a,
        id: id,
        version: vs,
        detail: (ref4 = opts != null ? opts.detail : void 0) != null ? ref4 : defaults.detail,
        references: (ref5 = opts != null ? opts.references : void 0) != null ? ref5 : defaults.references,
        item: item
      };
      input = isValidQuery(query);
      if (!input.isValid) {
        throw Error(createErrorMessage(input.errors, 'metadata query'));
      }
      return query;
    }

  };

  exports.MetadataQuery = query;

}).call(this);
